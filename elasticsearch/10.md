# 10. 대용량 처리를 위한 시스템 최적화

## 10.1 노드 실행환경과 JVM 옵션
* 엘라스틱서치와 루씬(jar - 라이브러리) 는 ES 인스턴스가 생성되면 JVM 위에서 함께 동작된다.
### 10.1.1 엘라스틱서치 릴리스 노트
### 10.1.2 실행시 자바8 이상을 사용해야 하는 이유
* 과거에 비해 CPU/메모리 자원이 넉넉하게 제공됨.
* 큰 물리 메모리 사용
```
- 기존 32비트 운영체제에서는 물리 메모리를 4GB(2^32) 밖에 인식하지 못하지만,
- 64비트에서는 수백GB(2^64)를 인식하는 것이 가능하다.
- 하지만 CPU상의 레지스터도 64비트로 동작해야 하기 때문에 하나의 CPU 명령어를 처리하는 데 필요한 레지스터 연산에도 32비트에 비해 2배 이상의 주소 공간이 필요해진다.
- 자바 및 JVM도 64비트를 제공하게 됨.
- 따라서 사용가능한 힙 메모리도 과거에 비해 더 많이 할당되는게 가능해 짐.
```
* 다수의 CPU 사용
```
- 기존의 멀티 스레드 기반의 프로그래밍은 다수의 CPU가 탑재된 환경에서는 오히려 비효율적인 경우가 있음.
- 자바8의 스트림/람다는 언어 차원에서 손쉽게 멀티 코어로 함수를 동작시킬 수 있음.
- 이러한 특수한 함수를 람다라 부르며, 람다를 이용해 로직을 작성하고 스트림에 입력하면 다수의 CPU에서 동시에 데이터가 처리되며, 모든 CPU에서 처리가 끝날 때 까지 결과를 기다리게 됨. (일종의 맵리듀스 처럼)
```

```JAVA
//간단한 람다 표현식
Stream<String> words = Stream.of("Java", "Magazine", "is", "the", "best");

Map<String, Long> letterToCount = words.map(w -> w.split(""))
                                  .flatMap(Arrays::stream)
                                  .collect(groupingBy(identity(), counting()));      
```
* 이러한 과정은 언어 차원에서 블랙박스로 이루어짐. 람다식 하나만으로도 자바 8을 써야할 이유는 분명하다.

### 10.1.3 항상 최신 버전의 엘라스틱서치를 사용해야 하는 이유
### 10.1.4 자바8에서 제공하는 JVM 옵션
### 10.1.5 엘라스틱서치에 적용된 JVM 옵션
* ES는 분산 시스템의 특성상 스케일 인/아웃이 빈번하게 일어나며, 장애를 복구하거나 Reindex 작업에 의해 일어나는 데이터 리밸런싱에 의해 많은 메모리를 사용한다.
* 전체적인 성능 향상을 위해 다수의 JVM 옵션을 반드시 튜닝해야 한다.
* 하지만 ES는 다년간 이러한 문제를 다뤘으며, **JVM옵션도 대부분 최적화되어 제공한다.**
* jvm.option 파일에는 기본적으로 제공하는 JVM 힙 크기가 1GB로 설정되어있는데, 실제 운영환경에서는 이를 반드시 **더 큰 크기로 수정해야 한다.**
* 힙 크기 변경 외에는 기본 설정된 JVM 옵션을 그대로 사용하는 것이 좋다.
<br>

## 10.2 힙 크기를 32GB 이하로 유지해야 하는 이유
* ES는 메모리를 많이 사용하는 애플리케이션이다.
* 시스템에서 제공되는 물리 메모리를 JVM 힙에 할당해서 ES가 사용하도록 설정할 수 있음.
* 너무 작은 힙 크기는 OOM을 발생시킬 수 있으며, 반대로 너무 크면 FullGC가 발생할 때 STW를 발생시킬 수 있다.
### 10.2.1 엘라스틱서치와 힙 크기
* Xms(최소 힙)와 Xmx(최대 힙)는 같도록 권장한다. ( https://www.elastic.co/guide/en/elasticsearch/reference/7.1/heap-size.html )
* 운영체제에 50%의 메모리 공간을 보장하자.
```
- ES 샤드는 내부에 루씬을 가지고 있으며, 루씬은 세그먼트 생성/관리를 위해 커널 시스템 캐시를 최대한 많이 활용한다.
- 실시간 검색을 위해서는 루씬이 최대한 많은 시스템 캐시를 확보하도록 지원해야 한다.
- 시스템 캐시는 커널 내에 존재하는 운영체제가 갖고있는 메모리 공간
- 그러므로 물리적인 메모리 공간의 50% 정도는 운영체제가 자유롭게 사용하도록 할당하고,
- 나머지를 ES 힙으로 할당하는것이 적절하다.
```
* 자바 8 기반에서는 힙 크기를 32GB 이상 사용하지 말자
```
- 메모리가 128GB인 하드웨어로 가정
1] 64GB 힙을 가지는 엘라스틱서치 노드 1개
2] 32GB 힙을 가지는 엘라스틱서치 노드 2개
2를 권장한다.

- 모든 자바기반의 어플리케이션에서는 Object Pointer 정책이 모두 동일하게 적용된다.
- Object Pointer 정책은 객체의 메모리 번지를 표현하는 주솟값이다.
- 자바 JVM은 32비트 JMV과, 64비트 JVM이 별도로 제공된다.
- 주솟값은 각각 32,64가 아닌, 둘 다 기본적으로 32비트 주솟값을 가지고 동작한다.
- 그 이유는 모든 JVM이 기본적으로 32비트 Object Pointer를 사용하고 있기 떄문이다.
```

## 10.2.2 Ordinary Object Pointer
* 자바에서는 모든 객체가 힙 영역에 생성된다.
* 이렇게 생성된 객체는 모두 포인터를 가지고 있고, 이를 통해 객체에 접근한다.
* JVM은 힙 영역에 생성된 객체에 접근하기 위해 포인터의 주소를 OOP 라고 하는 특수한 자료구조로 만들어서 관리하고 있으며, 이러한 OOP 들은 CPU의 처리 단위에 따라 동작하는 방식이 약간씩 달라진다.
```
* 32비트 시스템 : 32비트(2^32)까지 표현할 수 있기 때문에 최대 4GB까지의 주소공간을 가리킬 수 있다.
* 64비트 시스템 : 64비트(2^32)까지 표현할 수 있기 때문에 이론상 18EB(엑사바이트) 까지의 주소공간을 가리킬 수 있다.

- 32비트 시스템은 하나의 포인터를 표현하기 위해 32비트가 필요하다.
- 32비트를 이용하면 최대 4GB의 메모리 주소밖에 가리킬 수 없는데, 이러한 이유로 4GB 메모리밖에 사용할 수 없다.
- 64비트의 경우, 메모리상 하나의 주소를 가리키는 포인터 1개를 64비트로 표현하다보니 많은 메모리 공간의 낭비가 발생한다.
- 기존보다 인식 가능한 물리적 메모리의 크기가 늘긴 했지만, 메모리의 물리적인 공간 활용성은 상대적으로 낮아짐.
- 그뿐 아니라 CPU 내부의 LLc, L1, L2 캐시들은 지속적으로 값의 이동이 일어나는데, 64비트가 더 큰 대역폭을 소모한다.

```
